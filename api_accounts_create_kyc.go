/*
Lemonway DirectKit API 2.0

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// AccountsCreateKYCApiService AccountsCreateKYCApi service
type AccountsCreateKYCApiService service

type ApiAccountsAddUltimateBeneficialOwnerRequest struct {
	ctx context.Context
	ApiService *AccountsCreateKYCApiService
	accountId string
	authorization *string
	pSUIPAddress *string
	parameters *AddUltimateBeneficialOwnerInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiAccountsAddUltimateBeneficialOwnerRequest) Authorization(authorization string) ApiAccountsAddUltimateBeneficialOwnerRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiAccountsAddUltimateBeneficialOwnerRequest) PSUIPAddress(pSUIPAddress string) ApiAccountsAddUltimateBeneficialOwnerRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiAccountsAddUltimateBeneficialOwnerRequest) Parameters(parameters AddUltimateBeneficialOwnerInput) ApiAccountsAddUltimateBeneficialOwnerRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiAccountsAddUltimateBeneficialOwnerRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiAccountsAddUltimateBeneficialOwnerRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiAccountsAddUltimateBeneficialOwnerRequest) PSUUserAgent(pSUUserAgent string) ApiAccountsAddUltimateBeneficialOwnerRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiAccountsAddUltimateBeneficialOwnerRequest) AuthorizationFromProvider(authType AuthType) ApiAccountsAddUltimateBeneficialOwnerRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsAddUltimateBeneficialOwnerRequest) AuthorizationBasicFromProvider() ApiAccountsAddUltimateBeneficialOwnerRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsAddUltimateBeneficialOwnerRequest) AuthorizationBearerFromProvider() ApiAccountsAddUltimateBeneficialOwnerRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiAccountsAddUltimateBeneficialOwnerRequest) Execute() (*AddUltimateBeneficialOwnerOutput, *http.Response, error) {
	return r.ApiService.AccountsAddUltimateBeneficialOwnerExecute(r)
}

/*
AccountsAddUltimateBeneficialOwner Create an Ultimate Beneficial Owner

The method enables you to link an Ultimate Beneficial Owner to a legal payment account.  
To be validated all Legal accounts need to provide their Ultimate Beneficial Owner information.  
An Ultimate Beneficial Owner is a natural person that owns directly or indirectly (i.e. through another entity)  
more than 25% of the shares/stock or voting rights of the legal entity, or a person having significant control over it   
through other means. Any company established in EEA or EU is obliged to obtain and maintain this information with the competent   
central register (as per article 30 of Directive 2015/843/EU).   
Similar requirements may also exist in other countries.  
In order to comply with AML-CTF legal provisions, payment institutions are required  
to identify the beneficial owner(s) of a legal entity(i.e.a company or an organisation).  
If the Legal Representative is also an Ultimate Beneficial Owner,  you can specify this information when creating or updating a legal account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Account ID
 @return ApiAccountsAddUltimateBeneficialOwnerRequest
*/
func (a *AccountsCreateKYCApiService) AccountsAddUltimateBeneficialOwner(ctx context.Context, accountId string) ApiAccountsAddUltimateBeneficialOwnerRequest {
	return ApiAccountsAddUltimateBeneficialOwnerRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return AddUltimateBeneficialOwnerOutput
func (a *AccountsCreateKYCApiService) AccountsAddUltimateBeneficialOwnerExecute(r ApiAccountsAddUltimateBeneficialOwnerRequest) (*AddUltimateBeneficialOwnerOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AddUltimateBeneficialOwnerOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsCreateKYCApiService.AccountsAddUltimateBeneficialOwner")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/accounts/{accountId}/ultimateBeneficialOwner"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, err
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(AddUltimateBeneficialOwnerInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountsDocumentsUploadPostRequest struct {
	ctx context.Context
	ApiService *AccountsCreateKYCApiService
	accountid string
	authorization *string
	pSUIPAddress *string
	parameters *UploadDocumentInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiAccountsDocumentsUploadPostRequest) Authorization(authorization string) ApiAccountsDocumentsUploadPostRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiAccountsDocumentsUploadPostRequest) PSUIPAddress(pSUIPAddress string) ApiAccountsDocumentsUploadPostRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiAccountsDocumentsUploadPostRequest) Parameters(parameters UploadDocumentInput) ApiAccountsDocumentsUploadPostRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiAccountsDocumentsUploadPostRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiAccountsDocumentsUploadPostRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiAccountsDocumentsUploadPostRequest) PSUUserAgent(pSUUserAgent string) ApiAccountsDocumentsUploadPostRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiAccountsDocumentsUploadPostRequest) AuthorizationFromProvider(authType AuthType) ApiAccountsDocumentsUploadPostRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsDocumentsUploadPostRequest) AuthorizationBasicFromProvider() ApiAccountsDocumentsUploadPostRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsDocumentsUploadPostRequest) AuthorizationBearerFromProvider() ApiAccountsDocumentsUploadPostRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiAccountsDocumentsUploadPostRequest) Execute() (*UploadDocumentOutput, *http.Response, error) {
	return r.ApiService.AccountsDocumentsUploadPostExecute(r)
}

/*
AccountsDocumentsUploadPost Upload Documents for KYC (Know Your Customers)

KYC is a regulatory obligation for Payment Institutions. European Directive 2015/849 of the European Parliament states this requirement    
for the prevention of the use of the financial system for the purposes of money laundering and terrorist financing.    

To upload documents for KYC use the following guidelines:  
* Use JPG, JPEG, PNG or PDF (maximum 2 pages) for ID documentation only (for example: Passport, Driving Licence and Residence Permit).  
* Maximum file upload size is **4MB** for automatic verification.    
* Minimum file upload size is **100KB**.  
* Full Colour, and straighten file.   
* Card ID: Scan both sides. One file should contain both sides (maximum 2 pages).  

**Important** Documents over 4MB and upto 10MB will be manually validated.  
**Note:** TIFF format is not accepted.  
**Note:** If a document has been rejected, it is still possible to use the same slot to upload a new file.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountid Account ID
 @return ApiAccountsDocumentsUploadPostRequest
*/
func (a *AccountsCreateKYCApiService) AccountsDocumentsUploadPost(ctx context.Context, accountid string) ApiAccountsDocumentsUploadPostRequest {
	return ApiAccountsDocumentsUploadPostRequest{
		ApiService: a,
		ctx: ctx,
		accountid: accountid,
	}
}

// Execute executes the request
//  @return UploadDocumentOutput
func (a *AccountsCreateKYCApiService) AccountsDocumentsUploadPostExecute(r ApiAccountsDocumentsUploadPostRequest) (*UploadDocumentOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UploadDocumentOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsCreateKYCApiService.AccountsDocumentsUploadPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/accounts/{accountid}/documents/upload"
	localVarPath = strings.Replace(localVarPath, "{"+"accountid"+"}", url.PathEscape(parameterToString(r.accountid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, err
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(UploadDocumentInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountsGetUltimateBeneficialOwnerRequest struct {
	ctx context.Context
	ApiService *AccountsCreateKYCApiService
	accountId string
	authorization *string
	pSUIPAddress *string
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiAccountsGetUltimateBeneficialOwnerRequest) Authorization(authorization string) ApiAccountsGetUltimateBeneficialOwnerRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiAccountsGetUltimateBeneficialOwnerRequest) PSUIPAddress(pSUIPAddress string) ApiAccountsGetUltimateBeneficialOwnerRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiAccountsGetUltimateBeneficialOwnerRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiAccountsGetUltimateBeneficialOwnerRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiAccountsGetUltimateBeneficialOwnerRequest) PSUUserAgent(pSUUserAgent string) ApiAccountsGetUltimateBeneficialOwnerRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiAccountsGetUltimateBeneficialOwnerRequest) AuthorizationFromProvider(authType AuthType) ApiAccountsGetUltimateBeneficialOwnerRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsGetUltimateBeneficialOwnerRequest) AuthorizationBasicFromProvider() ApiAccountsGetUltimateBeneficialOwnerRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsGetUltimateBeneficialOwnerRequest) AuthorizationBearerFromProvider() ApiAccountsGetUltimateBeneficialOwnerRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiAccountsGetUltimateBeneficialOwnerRequest) Execute() (*GetUltimateBeneficialOwnerOutput, *http.Response, error) {
	return r.ApiService.AccountsGetUltimateBeneficialOwnerExecute(r)
}

/*
AccountsGetUltimateBeneficialOwner Get all Ultimate Beneficial Owners associated to a payment account.

This method enables you get all the Ultimate Beneficial Owners associated to a legal payment account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Account ID
 @return ApiAccountsGetUltimateBeneficialOwnerRequest
*/
func (a *AccountsCreateKYCApiService) AccountsGetUltimateBeneficialOwner(ctx context.Context, accountId string) ApiAccountsGetUltimateBeneficialOwnerRequest {
	return ApiAccountsGetUltimateBeneficialOwnerRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return GetUltimateBeneficialOwnerOutput
func (a *AccountsCreateKYCApiService) AccountsGetUltimateBeneficialOwnerExecute(r ApiAccountsGetUltimateBeneficialOwnerRequest) (*GetUltimateBeneficialOwnerOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetUltimateBeneficialOwnerOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsCreateKYCApiService.AccountsGetUltimateBeneficialOwner")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/accounts/{accountId}ultimateBeneficialOwner"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, err
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountsIndividualPostRequest struct {
	ctx context.Context
	ApiService *AccountsCreateKYCApiService
	authorization *string
	pSUIPAddress *string
	parameters *RegisterIndividualAccountInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiAccountsIndividualPostRequest) Authorization(authorization string) ApiAccountsIndividualPostRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiAccountsIndividualPostRequest) PSUIPAddress(pSUIPAddress string) ApiAccountsIndividualPostRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiAccountsIndividualPostRequest) Parameters(parameters RegisterIndividualAccountInput) ApiAccountsIndividualPostRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiAccountsIndividualPostRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiAccountsIndividualPostRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiAccountsIndividualPostRequest) PSUUserAgent(pSUUserAgent string) ApiAccountsIndividualPostRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiAccountsIndividualPostRequest) AuthorizationFromProvider(authType AuthType) ApiAccountsIndividualPostRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsIndividualPostRequest) AuthorizationBasicFromProvider() ApiAccountsIndividualPostRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsIndividualPostRequest) AuthorizationBearerFromProvider() ApiAccountsIndividualPostRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiAccountsIndividualPostRequest) Execute() (*RegisterIndividualAccountOutput, *http.Response, error) {
	return r.ApiService.AccountsIndividualPostExecute(r)
}

/*
AccountsIndividualPost Create a New Individual Account

Lets you to create a individual payment account  
1. Your Client enter their data on your platform, for example on their profile space.  
2. Your server calls our Accounts API.  
3. Lemonway creates the payment account in your environment.  
4. Your system reads the method response and informs the user.   

We apply our validation rules for different parameters.   

**Check Injection:**      
* String parameters (email, name and so on) must not contain odd characters.  

**Names (first and last name)**    

* Not made-up names: "name", "nom", "prénom", "prenom", "lastname", "last_name", "last name", "firstname", "first_name", "first name", "name", "test", "unknow"      
* Names must have at least 2 characters with at least 1 vowel     
* The first name must not be the same as the last name     
* Using the same the same character 3 times in a row will cause an error    
* We might apply other validation rules, for example: in the case VIP (politician)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAccountsIndividualPostRequest
*/
func (a *AccountsCreateKYCApiService) AccountsIndividualPost(ctx context.Context) ApiAccountsIndividualPostRequest {
	return ApiAccountsIndividualPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RegisterIndividualAccountOutput
func (a *AccountsCreateKYCApiService) AccountsIndividualPostExecute(r ApiAccountsIndividualPostRequest) (*RegisterIndividualAccountOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RegisterIndividualAccountOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsCreateKYCApiService.AccountsIndividualPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/accounts/individual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, err
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(RegisterIndividualAccountInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountsKycStatusGetRequest struct {
	ctx context.Context
	ApiService *AccountsCreateKYCApiService
	updateDate *string
	authorization *string
	pSUIPAddress *string
	page *int32
	limit *int32
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// UTC Unix timestamp
func (r ApiAccountsKycStatusGetRequest) UpdateDate(updateDate string) ApiAccountsKycStatusGetRequest {
	r.updateDate = &updateDate
	return r
}

// Authorization bearer (OAuth 2)
func (r ApiAccountsKycStatusGetRequest) Authorization(authorization string) ApiAccountsKycStatusGetRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiAccountsKycStatusGetRequest) PSUIPAddress(pSUIPAddress string) ApiAccountsKycStatusGetRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

// Index start from 1, let null to get all
func (r ApiAccountsKycStatusGetRequest) Page(page int32) ApiAccountsKycStatusGetRequest {
	r.page = &page
	return r
}

// Default 20, let it null if no pagination
func (r ApiAccountsKycStatusGetRequest) Limit(limit int32) ApiAccountsKycStatusGetRequest {
	r.limit = &limit
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiAccountsKycStatusGetRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiAccountsKycStatusGetRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiAccountsKycStatusGetRequest) PSUUserAgent(pSUUserAgent string) ApiAccountsKycStatusGetRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiAccountsKycStatusGetRequest) AuthorizationFromProvider(authType AuthType) ApiAccountsKycStatusGetRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsKycStatusGetRequest) AuthorizationBasicFromProvider() ApiAccountsKycStatusGetRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsKycStatusGetRequest) AuthorizationBearerFromProvider() ApiAccountsKycStatusGetRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiAccountsKycStatusGetRequest) Execute() (*KycStatusOutput, *http.Response, error) {
	return r.ApiService.AccountsKycStatusGetExecute(r)
}

/*
AccountsKycStatusGet Find a user, document or an IBAN that has been modified since an entry date

Use to find users, documents, IBAN for which the status has changed since a specified date.  
**Note:** Returns the same user multiple times in the same request if his status has changed multiple time since a specified date.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAccountsKycStatusGetRequest
*/
func (a *AccountsCreateKYCApiService) AccountsKycStatusGet(ctx context.Context) ApiAccountsKycStatusGetRequest {
	return ApiAccountsKycStatusGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KycStatusOutput
func (a *AccountsCreateKYCApiService) AccountsKycStatusGetExecute(r ApiAccountsKycStatusGetRequest) (*KycStatusOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KycStatusOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsCreateKYCApiService.AccountsKycStatusGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/accounts/kycstatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, err
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.updateDate == nil {
        value, ok := localAdditionalValues["updateDate"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("updateDate is required and must be specified")
        }
        r.updateDate = &value
	}
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}

	localVarQueryParams.Add("updateDate", parameterToString(*r.updateDate, ""))
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountsLegalPostRequest struct {
	ctx context.Context
	ApiService *AccountsCreateKYCApiService
	authorization *string
	pSUIPAddress *string
	parameters *RegisterLegalAccountInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiAccountsLegalPostRequest) Authorization(authorization string) ApiAccountsLegalPostRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiAccountsLegalPostRequest) PSUIPAddress(pSUIPAddress string) ApiAccountsLegalPostRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiAccountsLegalPostRequest) Parameters(parameters RegisterLegalAccountInput) ApiAccountsLegalPostRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiAccountsLegalPostRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiAccountsLegalPostRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiAccountsLegalPostRequest) PSUUserAgent(pSUUserAgent string) ApiAccountsLegalPostRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiAccountsLegalPostRequest) AuthorizationFromProvider(authType AuthType) ApiAccountsLegalPostRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsLegalPostRequest) AuthorizationBasicFromProvider() ApiAccountsLegalPostRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsLegalPostRequest) AuthorizationBearerFromProvider() ApiAccountsLegalPostRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiAccountsLegalPostRequest) Execute() (*RegisterLegalAccountOutput, *http.Response, error) {
	return r.ApiService.AccountsLegalPostExecute(r)
}

/*
AccountsLegalPost Create a New Legal Account

Lets you to create a legal payment account:      
1. Your client enter their data on your platform, for example on their profile space.   
2. Your server calls our Accounts API.  
3. Lemonway creates the payment account in your environment.     
4. Your system reads the method response and informs the user.    

We apply validation rules for different parameters.   

**Check Injection:**    
* String parameters (email, name and so on) must not contain odd characters.

**Names (first and last name)**  

* Not made-up names: "name", "nom", "prénom", "prenom", "lastname", "last_name", "last name", "firstname", "first_name", "first name", "name", "test", "unknow"    
* Names must have at least 2 characters with at least 1 vowel  
* The first name must not be the same as the last name  
* Using the same the same character 3 times in a row will cause an error  
* We might apply other validation rules, for example: in the case VIP (politician)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAccountsLegalPostRequest
*/
func (a *AccountsCreateKYCApiService) AccountsLegalPost(ctx context.Context) ApiAccountsLegalPostRequest {
	return ApiAccountsLegalPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RegisterLegalAccountOutput
func (a *AccountsCreateKYCApiService) AccountsLegalPostExecute(r ApiAccountsLegalPostRequest) (*RegisterLegalAccountOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RegisterLegalAccountOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsCreateKYCApiService.AccountsLegalPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/accounts/legal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, err
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(RegisterLegalAccountInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountsUpdateUltimateBeneficialOwnerRequest struct {
	ctx context.Context
	ApiService *AccountsCreateKYCApiService
	accountId string
	ultimateBeneficialOwnerId int64
	authorization *string
	pSUIPAddress *string
	parameters *UpdateUltimateBeneficialOwnerInput
	pSUAcceptLanguage *string
	pSUUserAgent *string
}

// Authorization bearer (OAuth 2)
func (r ApiAccountsUpdateUltimateBeneficialOwnerRequest) Authorization(authorization string) ApiAccountsUpdateUltimateBeneficialOwnerRequest {
	r.authorization = &authorization
	return r
}

// IP address of the final client (PSU).
func (r ApiAccountsUpdateUltimateBeneficialOwnerRequest) PSUIPAddress(pSUIPAddress string) ApiAccountsUpdateUltimateBeneficialOwnerRequest {
	r.pSUIPAddress = &pSUIPAddress
	return r
}

func (r ApiAccountsUpdateUltimateBeneficialOwnerRequest) Parameters(parameters UpdateUltimateBeneficialOwnerInput) ApiAccountsUpdateUltimateBeneficialOwnerRequest {
	r.parameters = &parameters
	return r
}

// Response language accepted by final client (PSU). English by default
func (r ApiAccountsUpdateUltimateBeneficialOwnerRequest) PSUAcceptLanguage(pSUAcceptLanguage string) ApiAccountsUpdateUltimateBeneficialOwnerRequest {
	r.pSUAcceptLanguage = &pSUAcceptLanguage
	return r
}

// User-agent of the final client (PSU).
func (r ApiAccountsUpdateUltimateBeneficialOwnerRequest) PSUUserAgent(pSUUserAgent string) ApiAccountsUpdateUltimateBeneficialOwnerRequest {
	r.pSUUserAgent = &pSUUserAgent
	return r
}


// Use Authorization from given provider. Overrides usage of manually set Authorization header.
// Auth type describes authorization type to use, like "Bearer" or "Basic"
func (r ApiAccountsUpdateUltimateBeneficialOwnerRequest) AuthorizationFromProvider(authType AuthType) ApiAccountsUpdateUltimateBeneficialOwnerRequest {
    r.ctx = context.WithValue(r.ctx, authorizationFromProviderCtxKey, authType)
    return r
}

// Use Basic Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsUpdateUltimateBeneficialOwnerRequest) AuthorizationBasicFromProvider() ApiAccountsUpdateUltimateBeneficialOwnerRequest {
    return r.AuthorizationFromProvider(AuthTypeBasic)
}

// Use Bearer Authorization from given provider. Overrides usage of manually set Authorization header.
func (r ApiAccountsUpdateUltimateBeneficialOwnerRequest) AuthorizationBearerFromProvider() ApiAccountsUpdateUltimateBeneficialOwnerRequest {
    return r.AuthorizationFromProvider(AuthTypeBearer)
}

func (r ApiAccountsUpdateUltimateBeneficialOwnerRequest) Execute() (*UpdateUltimateBeneficialOwnerOutput, *http.Response, error) {
	return r.ApiService.AccountsUpdateUltimateBeneficialOwnerExecute(r)
}

/*
AccountsUpdateUltimateBeneficialOwner Update Ultimate Beneficial Owner data

This method enables you to update information related to an Ultimate Beneficial Owner.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Account ID
 @param ultimateBeneficialOwnerId UltimateBeneficial Owner ID
 @return ApiAccountsUpdateUltimateBeneficialOwnerRequest
*/
func (a *AccountsCreateKYCApiService) AccountsUpdateUltimateBeneficialOwner(ctx context.Context, accountId string, ultimateBeneficialOwnerId int64) ApiAccountsUpdateUltimateBeneficialOwnerRequest {
	return ApiAccountsUpdateUltimateBeneficialOwnerRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		ultimateBeneficialOwnerId: ultimateBeneficialOwnerId,
	}
}

// Execute executes the request
//  @return UpdateUltimateBeneficialOwnerOutput
func (a *AccountsCreateKYCApiService) AccountsUpdateUltimateBeneficialOwnerExecute(r ApiAccountsUpdateUltimateBeneficialOwnerRequest) (*UpdateUltimateBeneficialOwnerOutput, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateUltimateBeneficialOwnerOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsCreateKYCApiService.AccountsUpdateUltimateBeneficialOwner")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/accounts/{accountId}/ultimateBeneficialOwner/{UltimateBeneficialOwnerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"UltimateBeneficialOwnerId"+"}", url.PathEscape(parameterToString(r.ultimateBeneficialOwnerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
    localAdditionalValues := make(map[string]interface{})

    if r.ctx != nil {
        if authProviderAuthType, ok := r.ctx.Value(authorizationFromProviderCtxKey).(AuthType); ok && authProviderAuthType != "" {
            token, err := a.client.authProvider.GetToken()
            if err != nil {
                return localVarReturnValue, nil, err
            }
            localAdditionalValues["authorization"] = string(authProviderAuthType)+" "+token
        }
    }
	if r.authorization == nil {
        value, ok := localAdditionalValues["authorization"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("authorization is required and must be specified")
        }
        r.authorization = &value
	}
	if r.pSUIPAddress == nil {
        value, ok := localAdditionalValues["pSUIPAddress"].(string)
        if !ok {
            return localVarReturnValue, nil, reportError("pSUIPAddress is required and must be specified")
        }
        r.pSUIPAddress = &value
	}
	if r.parameters == nil {
        value, ok := localAdditionalValues["parameters"].(UpdateUltimateBeneficialOwnerInput)
        if !ok {
            return localVarReturnValue, nil, reportError("parameters is required and must be specified")
        }
        r.parameters = &value
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.pSUAcceptLanguage != nil {
		localVarHeaderParams["PSU-Accept-Language"] = parameterToString(*r.pSUAcceptLanguage, "")
	}
	localVarHeaderParams["PSU-IP-Address"] = parameterToString(*r.pSUIPAddress, "")
	if r.pSUUserAgent != nil {
		localVarHeaderParams["PSU-User-Agent"] = parameterToString(*r.pSUUserAgent, "")
	}
	// body params
	localVarPostBody = r.parameters
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
